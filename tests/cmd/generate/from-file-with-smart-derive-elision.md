```
$ kopium --derive=PartialEq --derive=Default --smart-derive-elision --filename tests/cmd/generate/crds/apis.apigatewayv2.services.k8s.aws.yaml
// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --derive=PartialEq --derive=Default --smart-derive-elision --filename tests/cmd/generate/crds/apis.apigatewayv2.services.k8s.aws.yaml
// kopium version: [..]

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}

use self::prelude::*;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
#[kube(group = "apigatewayv2.services.k8s.aws", version = "v1alpha1", kind = "API", plural = "apis")]
#[kube(namespaced)]
#[kube(status = "ApiStatus")]
#[kube(schema = "disabled")]
#[kube(derive="PartialEq")]
#[kube(derive="Default")]
pub struct ApiSpec {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiKeySelectionExpression")]
    pub api_key_selection_expression: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub basepath: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsConfiguration")]
    pub cors_configuration: Option<ApiCorsConfiguration>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialsARN")]
    pub credentials_arn: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableExecuteAPIEndpoint")]
    pub disable_execute_api_endpoint: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableSchemaValidation")]
    pub disable_schema_validation: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failOnWarnings")]
    pub fail_on_warnings: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "protocolType")]
    pub protocol_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeKey")]
    pub route_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectionExpression")]
    pub route_selection_expression: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct ApiCorsConfiguration {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    pub allow_credentials: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    pub allow_headers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    pub allow_methods: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    pub allow_origins: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    pub expose_headers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    pub max_age: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct ApiStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ackResourceMetadata")]
    pub ack_resource_metadata: Option<ApiStatusAckResourceMetadata>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiEndpoint")]
    pub api_endpoint: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGatewayManaged")]
    pub api_gateway_managed: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiID")]
    pub api_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "createdDate")]
    pub created_date: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "importInfo")]
    pub import_info: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub warnings: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct ApiStatusAckResourceMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub arn: Option<String>,
    #[serde(rename = "ownerAccountID")]
    pub owner_account_id: String,
    pub region: String,
}


```

```
$ kopium --derive=PartialEq --derive=Default --smart-derive-elision --filename tests/cmd/generate/crds/argocdexports.argoproj.io.yaml
// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --derive=PartialEq --derive=Default --smart-derive-elision --filename tests/cmd/generate/crds/argocdexports.argoproj.io.yaml
// kopium version: [..]

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
}

use self::prelude::*;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
#[kube(group = "argoproj.io", version = "v1alpha1", kind = "ArgoCDExport", plural = "argocdexports")]
#[kube(namespaced)]
#[kube(status = "ArgoCdExportStatus")]
#[kube(schema = "disabled")]
#[kube(derive="PartialEq")]
#[kube(derive="Default")]
pub struct ArgoCdExportSpec {
    pub argocd: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schedule: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<ArgoCdExportStorage>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct ArgoCdExportStorage {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub backend: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pvc: Option<ArgoCdExportStoragePvc>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct ArgoCdExportStoragePvc {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<ArgoCdExportStoragePvcDataSource>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceRef")]
    pub data_source_ref: Option<ArgoCdExportStoragePvcDataSourceRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdExportStoragePvcResources>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<ArgoCdExportStoragePvcSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributesClassName")]
    pub volume_attributes_class_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct ArgoCdExportStoragePvcDataSource {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    pub kind: String,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct ArgoCdExportStoragePvcDataSourceRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    pub kind: String,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct ArgoCdExportStoragePvcResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct ArgoCdExportStoragePvcSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ArgoCdExportStoragePvcSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct ArgoCdExportStoragePvcSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct ArgoCdExportStatus {
    pub phase: String,
}


```

```
$ kopium --derive=PartialEq --derive=Default --smart-derive-elision --filename tests/cmd/generate/crds/authorizers.apigatewayv2.services.k8s.aws.yaml
// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --derive=PartialEq --derive=Default --smart-derive-elision --filename tests/cmd/generate/crds/authorizers.apigatewayv2.services.k8s.aws.yaml
// kopium version: [..]

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}

use self::prelude::*;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
#[kube(group = "apigatewayv2.services.k8s.aws", version = "v1alpha1", kind = "Authorizer", plural = "authorizers")]
#[kube(namespaced)]
#[kube(status = "AuthorizerStatus")]
#[kube(schema = "disabled")]
#[kube(derive="PartialEq")]
#[kube(derive="Default")]
pub struct AuthorizerSpec {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiID")]
    pub api_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiRef")]
    pub api_ref: Option<AuthorizerApiRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizerCredentialsARN")]
    pub authorizer_credentials_arn: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizerPayloadFormatVersion")]
    pub authorizer_payload_format_version: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizerResultTTLInSeconds")]
    pub authorizer_result_ttl_in_seconds: Option<i64>,
    #[serde(rename = "authorizerType")]
    pub authorizer_type: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizerURI")]
    pub authorizer_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSimpleResponses")]
    pub enable_simple_responses: Option<bool>,
    #[serde(rename = "identitySource")]
    pub identity_source: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityValidationExpression")]
    pub identity_validation_expression: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jwtConfiguration")]
    pub jwt_configuration: Option<AuthorizerJwtConfiguration>,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct AuthorizerApiRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<AuthorizerApiRefFrom>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct AuthorizerApiRefFrom {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct AuthorizerJwtConfiguration {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub issuer: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct AuthorizerStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ackResourceMetadata")]
    pub ack_resource_metadata: Option<AuthorizerStatusAckResourceMetadata>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizerID")]
    pub authorizer_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct AuthorizerStatusAckResourceMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub arn: Option<String>,
    #[serde(rename = "ownerAccountID")]
    pub owner_account_id: String,
    pub region: String,
}


```

```
$ kopium --derive=PartialEq --derive=Default --smart-derive-elision --filename tests/cmd/generate/crds/postgresqls.acid.zalan.do.yaml
// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --derive=PartialEq --derive=Default --smart-derive-elision --filename tests/cmd/generate/crds/postgresqls.acid.zalan.do.yaml
// kopium version: [..]

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}

use self::prelude::*;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "acid.zalan.do", version = "v1", kind = "postgresql", plural = "postgresqls")]
#[kube(namespaced)]
#[kube(schema = "disabled")]
#[kube(derive="PartialEq")]
pub struct PostgresqlSpec {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalVolumes")]
    pub additional_volumes: Option<Vec<PostgresqlAdditionalVolumes>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedSourceRanges")]
    pub allowed_source_ranges: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clone: Option<PostgresqlClone>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionPooler")]
    pub connection_pooler: Option<PostgresqlConnectionPooler>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub databases: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dockerImage")]
    pub docker_image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConnectionPooler")]
    pub enable_connection_pooler: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableLogicalBackup")]
    pub enable_logical_backup: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableMasterLoadBalancer")]
    pub enable_master_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableMasterPoolerLoadBalancer")]
    pub enable_master_pooler_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableReplicaConnectionPooler")]
    pub enable_replica_connection_pooler: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableReplicaLoadBalancer")]
    pub enable_replica_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableReplicaPoolerLoadBalancer")]
    pub enable_replica_pooler_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableShmVolume")]
    pub enable_shm_volume: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initContainers")]
    pub init_containers: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "init_containers")]
    pub init_containers_x: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logicalBackupRetention")]
    pub logical_backup_retention: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logicalBackupSchedule")]
    pub logical_backup_schedule: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceWindows")]
    pub maintenance_windows: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "masterServiceAnnotations")]
    pub master_service_annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<PostgresqlNodeAffinity>,
    #[serde(rename = "numberOfInstances")]
    pub number_of_instances: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patroni: Option<PostgresqlPatroni>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAnnotations")]
    pub pod_annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podPriorityClassName")]
    pub pod_priority_class_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pod_priority_class_name")]
    pub pod_priority_class_name_x: Option<String>,
    pub postgresql: PostgresqlPostgresql,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preparedDatabases")]
    pub prepared_databases: Option<BTreeMap<String, PostgresqlPreparedDatabases>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaLoadBalancer")]
    pub replica_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaServiceAnnotations")]
    pub replica_service_annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresqlResources>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedulerName")]
    pub scheduler_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAnnotations")]
    pub service_annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sidecars: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spiloFSGroup")]
    pub spilo_fs_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spiloRunAsGroup")]
    pub spilo_run_as_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spiloRunAsUser")]
    pub spilo_run_as_user: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub standby: Option<PostgresqlStandby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub streams: Option<Vec<PostgresqlStreams>>,
    #[serde(rename = "teamId")]
    pub team_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<PostgresqlTls>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<PostgresqlTolerations>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useLoadBalancer")]
    pub use_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub users: Option<BTreeMap<String, Vec<String>>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usersIgnoringSecretRotation")]
    pub users_ignoring_secret_rotation: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usersWithInPlaceSecretRotation")]
    pub users_with_in_place_secret_rotation: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usersWithSecretRotation")]
    pub users_with_secret_rotation: Option<Vec<String>>,
    pub volume: PostgresqlVolume,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlAdditionalVolumes {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isSubPathExpr")]
    pub is_sub_path_expr: Option<bool>,
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetContainers")]
    pub target_containers: Option<Vec<String>>,
    #[serde(rename = "volumeSource")]
    pub volume_source: BTreeMap<String, serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlClone {
    pub cluster: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_access_key_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_endpoint: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_force_path_style: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_secret_access_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_wal_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uid: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlConnectionPooler {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dockerImage")]
    pub docker_image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxDBConnections")]
    pub max_db_connections: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<PostgresqlConnectionPoolerMode>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberOfInstances")]
    pub number_of_instances: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresqlConnectionPoolerResources>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schema: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PostgresqlConnectionPoolerMode {
    #[serde(rename = "session")]
    Session,
    #[serde(rename = "transaction")]
    Transaction,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlConnectionPoolerResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<PostgresqlConnectionPoolerResourcesLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<PostgresqlConnectionPoolerResourcesRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlConnectionPoolerResourcesLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlConnectionPoolerResourcesRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlPatroni {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failsafe_mode: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub initdb: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub loop_wait: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maximum_lag_on_failover: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pg_hba: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub retry_timeout: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub slots: Option<BTreeMap<String, BTreeMap<String, String>>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub synchronous_mode: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub synchronous_mode_strict: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub synchronous_node_count: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PostgresqlPostgresql {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parameters: Option<BTreeMap<String, String>>,
    pub version: PostgresqlPostgresqlVersion,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PostgresqlPostgresqlVersion {
    #[serde(rename = "13")]
    r#_13,
    #[serde(rename = "14")]
    r#_14,
    #[serde(rename = "15")]
    r#_15,
    #[serde(rename = "16")]
    r#_16,
    #[serde(rename = "17")]
    r#_17,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlPreparedDatabases {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultUsers")]
    pub default_users: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extensions: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schemas: Option<BTreeMap<String, PostgresqlPreparedDatabasesSchemas>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretNamespace")]
    pub secret_namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlPreparedDatabasesSchemas {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultRoles")]
    pub default_roles: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultUsers")]
    pub default_users: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<PostgresqlResourcesLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<PostgresqlResourcesRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlResourcesLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hugepages-1Gi")]
    pub hugepages_1gi: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hugepages-2Mi")]
    pub hugepages_2mi: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlResourcesRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hugepages-1Gi")]
    pub hugepages_1gi: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hugepages-2Mi")]
    pub hugepages_2mi: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlStandby {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gs_wal_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_wal_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub standby_host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub standby_port: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlStreams {
    #[serde(rename = "applicationId")]
    pub application_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchSize")]
    pub batch_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    pub database: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableRecovery")]
    pub enable_recovery: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filter: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    pub tables: BTreeMap<String, PostgresqlStreamsTables>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlStreamsTables {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventType")]
    pub event_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idColumn")]
    pub id_column: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreRecovery")]
    pub ignore_recovery: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "payloadColumn")]
    pub payload_column: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recoveryEventType")]
    pub recovery_event_type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlTls {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caSecretName")]
    pub ca_secret_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateFile")]
    pub certificate_file: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKeyFile")]
    pub private_key_file: Option<String>,
    #[serde(rename = "secretName")]
    pub secret_name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlTolerations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<PostgresqlTolerationsEffect>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<PostgresqlTolerationsOperator>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PostgresqlTolerationsEffect {
    NoExecute,
    NoSchedule,
    PreferNoSchedule,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PostgresqlTolerationsOperator {
    Equal,
    Exists,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlVolume {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iops: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isSubPathExpr")]
    pub is_sub_path_expr: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<PostgresqlVolumeSelector>,
    pub size: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClass")]
    pub storage_class: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub throughput: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlVolumeSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresqlVolumeSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, serde_json::Value>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PostgresqlVolumeSelectorMatchExpressions {
    pub key: String,
    pub operator: PostgresqlVolumeSelectorMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PostgresqlVolumeSelectorMatchExpressionsOperator {
    DoesNotExist,
    Exists,
    In,
    NotIn,
}


```
