```
$ kopium --derive=PartialEq --derive=Default --smart-derive-elision --filename tests/cmd/generate/crds/apis.apigatewayv2.services.k8s.aws.yaml
// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --derive=PartialEq --derive=Default --smart-derive-elision --filename tests/cmd/generate/crds/apis.apigatewayv2.services.k8s.aws.yaml
// kopium version: [..]

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
#[kube(group = "apigatewayv2.services.k8s.aws", version = "v1alpha1", kind = "API", plural = "apis")]
#[kube(namespaced)]
#[kube(status = "APIStatus")]
#[kube(schema = "disabled")]
#[kube(derive="PartialEq")]
#[kube(derive="Default")]
pub struct ApiSpec {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiKeySelectionExpression")]
    pub api_key_selection_expression: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub basepath: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsConfiguration")]
    pub cors_configuration: Option<ApiSpecCorsConfiguration>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialsARN")]
    pub credentials_arn: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableExecuteAPIEndpoint")]
    pub disable_execute_api_endpoint: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableSchemaValidation")]
    pub disable_schema_validation: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failOnWarnings")]
    pub fail_on_warnings: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "protocolType")]
    pub protocol_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeKey")]
    pub route_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectionExpression")]
    pub route_selection_expression: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct ApiSpecCorsConfiguration {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    pub allow_credentials: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    pub allow_headers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    pub allow_methods: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    pub allow_origins: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    pub expose_headers: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    pub max_age: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct ApiStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ackResourceMetadata")]
    pub ack_resource_metadata: Option<ApiStatusAckResourceMetadata>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiEndpoint")]
    pub api_endpoint: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGatewayManaged")]
    pub api_gateway_managed: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiID")]
    pub api_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "createdDate")]
    pub created_date: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "importInfo")]
    pub import_info: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub warnings: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct ApiStatusAckResourceMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub arn: Option<String>,
    #[serde(rename = "ownerAccountID")]
    pub owner_account_id: String,
    pub region: String,
}


```

```
$ kopium --derive=PartialEq --derive=Default --smart-derive-elision --filename tests/cmd/generate/crds/argocdexports.argoproj.io.yaml
// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --derive=PartialEq --derive=Default --smart-derive-elision --filename tests/cmd/generate/crds/argocdexports.argoproj.io.yaml
// kopium version: [..]

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
}
use self::prelude::*;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
#[kube(group = "argoproj.io", version = "v1alpha1", kind = "ArgoCDExport", plural = "argocdexports")]
#[kube(namespaced)]
#[kube(status = "ArgoCDExportStatus")]
#[kube(schema = "disabled")]
#[kube(derive="PartialEq")]
#[kube(derive="Default")]
pub struct ArgoCdExportSpec {
    pub argocd: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schedule: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<ArgoCdExportSpecStorage>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct ArgoCdExportSpecStorage {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub backend: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pvc: Option<ArgoCdExportSpecStoragePvc>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct ArgoCdExportSpecStoragePvc {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<ArgoCdExportSpecStoragePvcDataSource>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceRef")]
    pub data_source_ref: Option<ArgoCdExportSpecStoragePvcDataSourceRef>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdExportSpecStoragePvcResources>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<ArgoCdExportSpecStoragePvcSelector>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributesClassName")]
    pub volume_attributes_class_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct ArgoCdExportSpecStoragePvcDataSource {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    pub kind: String,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct ArgoCdExportSpecStoragePvcDataSourceRef {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    pub kind: String,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct ArgoCdExportSpecStoragePvcResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct ArgoCdExportSpecStoragePvcSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ArgoCdExportSpecStoragePvcSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct ArgoCdExportSpecStoragePvcSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct ArgoCdExportStatus {
    pub phase: String,
}


```

```
$ kopium --derive=PartialEq --derive=Default --smart-derive-elision --filename tests/cmd/generate/crds/authorizers.apigatewayv2.services.k8s.aws.yaml
// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --derive=PartialEq --derive=Default --smart-derive-elision --filename tests/cmd/generate/crds/authorizers.apigatewayv2.services.k8s.aws.yaml
// kopium version: [..]

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
#[kube(group = "apigatewayv2.services.k8s.aws", version = "v1alpha1", kind = "Authorizer", plural = "authorizers")]
#[kube(namespaced)]
#[kube(status = "AuthorizerStatus")]
#[kube(schema = "disabled")]
#[kube(derive="PartialEq")]
#[kube(derive="Default")]
pub struct AuthorizerSpec {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiID")]
    pub api_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiRef")]
    pub api_ref: Option<AuthorizerApiRef>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizerCredentialsARN")]
    pub authorizer_credentials_arn: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizerPayloadFormatVersion")]
    pub authorizer_payload_format_version: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizerResultTTLInSeconds")]
    pub authorizer_result_ttl_in_seconds: Option<i64>,
    #[serde(rename = "authorizerType")]
    pub authorizer_type: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizerURI")]
    pub authorizer_uri: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSimpleResponses")]
    pub enable_simple_responses: Option<bool>,
    #[serde(rename = "identitySource")]
    pub identity_source: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityValidationExpression")]
    pub identity_validation_expression: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jwtConfiguration")]
    pub jwt_configuration: Option<AuthorizerJwtConfiguration>,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct AuthorizerApiRef {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<AuthorizerApiRefFrom>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct AuthorizerApiRefFrom {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct AuthorizerJwtConfiguration {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub issuer: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct AuthorizerStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ackResourceMetadata")]
    pub ack_resource_metadata: Option<AuthorizerStatusAckResourceMetadata>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizerID")]
    pub authorizer_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct AuthorizerStatusAckResourceMetadata {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub arn: Option<String>,
    #[serde(rename = "ownerAccountID")]
    pub owner_account_id: String,
    pub region: String,
}


```

```
$ kopium --derive=PartialEq --derive=Default --smart-derive-elision --filename tests/cmd/generate/crds/postgresqls.acid.zalan.do.yaml
// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --derive=PartialEq --derive=Default --smart-derive-elision --filename tests/cmd/generate/crds/postgresqls.acid.zalan.do.yaml
// kopium version: [..]

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[kube(group = "acid.zalan.do", version = "v1", kind = "postgresql", plural = "postgresqls")]
#[kube(namespaced)]
#[kube(schema = "disabled")]
#[kube(derive="PartialEq")]
pub struct PostgresqlSpec {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalVolumes")]
    pub additional_volumes: Option<Vec<PostgresqlSpecAdditionalVolumes>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedSourceRanges")]
    pub allowed_source_ranges: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clone: Option<PostgresqlSpecClone>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionPooler")]
    pub connection_pooler: Option<PostgresqlSpecConnectionPooler>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub databases: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dockerImage")]
    pub docker_image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConnectionPooler")]
    pub enable_connection_pooler: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableLogicalBackup")]
    pub enable_logical_backup: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableMasterLoadBalancer")]
    pub enable_master_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableMasterPoolerLoadBalancer")]
    pub enable_master_pooler_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableReplicaConnectionPooler")]
    pub enable_replica_connection_pooler: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableReplicaLoadBalancer")]
    pub enable_replica_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableReplicaPoolerLoadBalancer")]
    pub enable_replica_pooler_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableShmVolume")]
    pub enable_shm_volume: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initContainers")]
    pub init_containers: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "init_containers")]
    pub init_containers_x: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logicalBackupRetention")]
    pub logical_backup_retention: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logicalBackupSchedule")]
    pub logical_backup_schedule: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceWindows")]
    pub maintenance_windows: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "masterServiceAnnotations")]
    pub master_service_annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<PostgresqlSpecNodeAffinity>,
    #[serde(rename = "numberOfInstances")]
    pub number_of_instances: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patroni: Option<PostgresqlSpecPatroni>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAnnotations")]
    pub pod_annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podPriorityClassName")]
    pub pod_priority_class_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pod_priority_class_name")]
    pub pod_priority_class_name_x: Option<String>,
    pub postgresql: PostgresqlSpecPostgresql,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preparedDatabases")]
    pub prepared_databases: Option<BTreeMap<String, PostgresqlSpecPreparedDatabases>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaLoadBalancer")]
    pub replica_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaServiceAnnotations")]
    pub replica_service_annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresqlSpecResources>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedulerName")]
    pub scheduler_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAnnotations")]
    pub service_annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sidecars: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spiloFSGroup")]
    pub spilo_fs_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spiloRunAsGroup")]
    pub spilo_run_as_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spiloRunAsUser")]
    pub spilo_run_as_user: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub standby: Option<PostgresqlSpecStandby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub streams: Option<Vec<PostgresqlSpecStreams>>,
    #[serde(rename = "teamId")]
    pub team_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<PostgresqlSpecTls>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<PostgresqlSpecTolerations>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useLoadBalancer")]
    pub use_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub users: Option<BTreeMap<String, Vec<String>>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usersIgnoringSecretRotation")]
    pub users_ignoring_secret_rotation: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usersWithInPlaceSecretRotation")]
    pub users_with_in_place_secret_rotation: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usersWithSecretRotation")]
    pub users_with_secret_rotation: Option<Vec<String>>,
    pub volume: PostgresqlSpecVolume,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecAdditionalVolumes {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isSubPathExpr")]
    pub is_sub_path_expr: Option<bool>,
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetContainers")]
    pub target_containers: Option<Vec<String>>,
    #[serde(rename = "volumeSource")]
    pub volume_source: BTreeMap<String, serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecClone {
    pub cluster: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_access_key_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_endpoint: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_force_path_style: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_secret_access_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_wal_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uid: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecConnectionPooler {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dockerImage")]
    pub docker_image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxDBConnections")]
    pub max_db_connections: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<PostgresqlSpecConnectionPoolerMode>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberOfInstances")]
    pub number_of_instances: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresqlSpecConnectionPoolerResources>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schema: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PostgresqlSpecConnectionPoolerMode {
    #[serde(rename = "session")]
    Session,
    #[serde(rename = "transaction")]
    Transaction,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecConnectionPoolerResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<PostgresqlSpecConnectionPoolerResourcesLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<PostgresqlSpecConnectionPoolerResourcesRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecConnectionPoolerResourcesLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecConnectionPoolerResourcesRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecPatroni {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failsafe_mode: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub initdb: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub loop_wait: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maximum_lag_on_failover: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pg_hba: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub retry_timeout: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub slots: Option<BTreeMap<String, BTreeMap<String, String>>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub synchronous_mode: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub synchronous_mode_strict: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub synchronous_node_count: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PostgresqlSpecPostgresql {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parameters: Option<BTreeMap<String, String>>,
    pub version: PostgresqlSpecPostgresqlVersion,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PostgresqlSpecPostgresqlVersion {
    #[serde(rename = "13")]
    r#_13,
    #[serde(rename = "14")]
    r#_14,
    #[serde(rename = "15")]
    r#_15,
    #[serde(rename = "16")]
    r#_16,
    #[serde(rename = "17")]
    r#_17,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecPreparedDatabases {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultUsers")]
    pub default_users: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extensions: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schemas: Option<BTreeMap<String, PostgresqlSpecPreparedDatabasesSchemas>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretNamespace")]
    pub secret_namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecPreparedDatabasesSchemas {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultRoles")]
    pub default_roles: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultUsers")]
    pub default_users: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<PostgresqlSpecResourcesLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<PostgresqlSpecResourcesRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecResourcesLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hugepages-1Gi")]
    pub hugepages_1gi: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hugepages-2Mi")]
    pub hugepages_2mi: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecResourcesRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hugepages-1Gi")]
    pub hugepages_1gi: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hugepages-2Mi")]
    pub hugepages_2mi: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecStandby {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gs_wal_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_wal_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub standby_host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub standby_port: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecStreams {
    #[serde(rename = "applicationId")]
    pub application_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchSize")]
    pub batch_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    pub database: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableRecovery")]
    pub enable_recovery: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filter: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    pub tables: BTreeMap<String, PostgresqlSpecStreamsTables>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecStreamsTables {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventType")]
    pub event_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idColumn")]
    pub id_column: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreRecovery")]
    pub ignore_recovery: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "payloadColumn")]
    pub payload_column: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recoveryEventType")]
    pub recovery_event_type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecTls {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caSecretName")]
    pub ca_secret_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateFile")]
    pub certificate_file: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKeyFile")]
    pub private_key_file: Option<String>,
    #[serde(rename = "secretName")]
    pub secret_name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecTolerations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<PostgresqlSpecTolerationsEffect>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<PostgresqlSpecTolerationsOperator>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PostgresqlSpecTolerationsEffect {
    NoExecute,
    NoSchedule,
    PreferNoSchedule,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PostgresqlSpecTolerationsOperator {
    Equal,
    Exists,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecVolume {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iops: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isSubPathExpr")]
    pub is_sub_path_expr: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<PostgresqlSpecVolumeSelector>,
    pub size: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClass")]
    pub storage_class: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub throughput: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Default)]
pub struct PostgresqlSpecVolumeSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresqlSpecVolumeSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, serde_json::Value>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct PostgresqlSpecVolumeSelectorMatchExpressions {
    pub key: String,
    pub operator: PostgresqlSpecVolumeSelectorMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub enum PostgresqlSpecVolumeSelectorMatchExpressionsOperator {
    DoesNotExist,
    Exists,
    In,
    NotIn,
}


```
