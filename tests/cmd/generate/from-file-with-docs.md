```
$ kopium --docs --filename tests/cmd/generate/crds/apis.apigatewayv2.services.k8s.aws.yaml
// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename tests/cmd/generate/crds/apis.apigatewayv2.services.k8s.aws.yaml
// kopium version: [..]

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// ApiSpec defines the desired state of Api.
/// 
/// Represents an API.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug)]
#[kube(group = "apigatewayv2.services.k8s.aws", version = "v1alpha1", kind = "API", plural = "apis")]
#[kube(namespaced)]
#[kube(status = "ApiStatus")]
#[kube(schema = "disabled")]
pub struct ApiSpec {
    /// An API key selection expression. Supported only for WebSocket APIs. See API
    /// Key Selection Expressions (<https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-selection-expressions.html#apigateway-websocket-api-apikey-selection-expressions).>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiKeySelectionExpression")]
    pub api_key_selection_expression: Option<String>,
    /// Specifies how to interpret the base path of the API during import. Valid
    /// values are ignore, prepend, and split. The default value is ignore. To learn
    /// more, see Set the OpenAPI basePath Property (<https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-import-api-basePath.html).>
    /// Supported only for HTTP APIs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub basepath: Option<String>,
    /// The OpenAPI definition. Supported only for HTTP APIs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
    /// A CORS configuration. Supported only for HTTP APIs. See Configuring CORS
    /// (<https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-cors.html)>
    /// for more information.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "corsConfiguration")]
    pub cors_configuration: Option<ApiCorsConfiguration>,
    /// This property is part of quick create. It specifies the credentials required
    /// for the integration, if any. For a Lambda integration, three options are
    /// available. To specify an IAM Role for API Gateway to assume, use the role's
    /// Amazon Resource Name (ARN). To require that the caller's identity be passed
    /// through from the request, specify arn:aws:iam::*:user/*. To use resource-based
    /// permissions on supported AWS services, specify null. Currently, this property
    /// is not used for HTTP integrations. Supported only for HTTP APIs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "credentialsARN")]
    pub credentials_arn: Option<String>,
    /// The description of the API.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Specifies whether clients can invoke your API by using the default execute-api
    /// endpoint. By default, clients can invoke your API with the default <https://{api_id}.execute-api.{region}.amazonaws.com>
    /// endpoint. To require that clients use a custom domain name to invoke your
    /// API, disable the default endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableExecuteAPIEndpoint")]
    pub disable_execute_api_endpoint: Option<bool>,
    /// Avoid validating models when creating a deployment. Supported only for WebSocket
    /// APIs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableSchemaValidation")]
    pub disable_schema_validation: Option<bool>,
    /// Specifies whether to rollback the API creation when a warning is encountered.
    /// By default, API creation continues if a warning is encountered.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failOnWarnings")]
    pub fail_on_warnings: Option<bool>,
    /// The name of the API.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The API protocol.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "protocolType")]
    pub protocol_type: Option<String>,
    /// This property is part of quick create. If you don't specify a routeKey, a
    /// default route of $default is created. The $default route acts as a catch-all
    /// for any request made to your API, for a particular stage. The $default route
    /// key can't be modified. You can add routes after creating the API, and you
    /// can update the route keys of additional routes. Supported only for HTTP APIs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeKey")]
    pub route_key: Option<String>,
    /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression
    /// must be ${request.method} ${request.path}. If not provided, this will be
    /// the default for HTTP APIs. This property is required for WebSocket APIs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "routeSelectionExpression")]
    pub route_selection_expression: Option<String>,
    /// The collection of tags. Each tag element is associated with a given resource.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<BTreeMap<String, String>>,
    /// This property is part of quick create. Quick create produces an API with
    /// an integration, a default catch-all route, and a default stage which is configured
    /// to automatically deploy changes. For HTTP integrations, specify a fully qualified
    /// URL. For Lambda integrations, specify a function ARN. The type of the integration
    /// will be HTTP_PROXY or AWS_PROXY, respectively. Supported only for HTTP APIs.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
    /// A version identifier for the API.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// A CORS configuration. Supported only for HTTP APIs. See Configuring CORS
/// (<https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-cors.html)>
/// for more information.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ApiCorsConfiguration {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowCredentials")]
    pub allow_credentials: Option<bool>,
    /// Represents a collection of allowed headers. Supported only for HTTP APIs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowHeaders")]
    pub allow_headers: Option<Vec<String>>,
    /// Represents a collection of methods. Supported only for HTTP APIs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowMethods")]
    pub allow_methods: Option<Vec<String>>,
    /// Represents a collection of origins. Supported only for HTTP APIs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowOrigins")]
    pub allow_origins: Option<Vec<String>>,
    /// Represents a collection of allowed headers. Supported only for HTTP APIs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "exposeHeaders")]
    pub expose_headers: Option<Vec<String>>,
    /// An integer with a value between -1 and 86400. Supported only for HTTP APIs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxAge")]
    pub max_age: Option<i64>,
}

/// APIStatus defines the observed state of API
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ApiStatus {
    /// All CRs managed by ACK have a common `Status.ACKResourceMetadata` member
    /// that is used to contain resource sync state, account ownership,
    /// constructed ARN for the resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ackResourceMetadata")]
    pub ack_resource_metadata: Option<ApiStatusAckResourceMetadata>,
    /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com.
    /// The stage name is typically appended to this URI to form a complete path
    /// to a deployed API stage.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiEndpoint")]
    pub api_endpoint: Option<String>,
    /// Specifies whether an API is managed by API Gateway. You can't update or delete
    /// a managed API by using API Gateway. A managed API can be deleted only through
    /// the tooling or service that created it.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGatewayManaged")]
    pub api_gateway_managed: Option<bool>,
    /// The API ID.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiID")]
    pub api_id: Option<String>,
    /// All CRs managed by ACK have a common `Status.Conditions` member that
    /// contains a collection of `ackv1alpha1.Condition` objects that describe
    /// the various terminal states of the CR and its backend AWS service API
    /// resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// The timestamp when the API was created.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "createdDate")]
    pub created_date: Option<String>,
    /// The validation information during API import. This may include particular
    /// properties of your OpenAPI definition which are ignored during import. Supported
    /// only for HTTP APIs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "importInfo")]
    pub import_info: Option<Vec<String>>,
    /// The warning messages reported when failonwarnings is turned on during API
    /// import.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub warnings: Option<Vec<String>>,
}

/// All CRs managed by ACK have a common `Status.ACKResourceMetadata` member
/// that is used to contain resource sync state, account ownership,
/// constructed ARN for the resource
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ApiStatusAckResourceMetadata {
    /// ARN is the Amazon Resource Name for the resource. This is a
    /// globally-unique identifier and is set only by the ACK service controller
    /// once the controller has orchestrated the creation of the resource OR
    /// when it has verified that an "adopted" resource (a resource where the
    /// ARN annotation was set by the Kubernetes user on the CR) exists and
    /// matches the supplied CR's Spec field values.
    /// <https://github.com/aws/aws-controllers-k8s/issues/270>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub arn: Option<String>,
    /// OwnerAccountID is the AWS Account ID of the account that owns the
    /// backend AWS service API resource.
    #[serde(rename = "ownerAccountID")]
    pub owner_account_id: String,
    /// Region is the AWS region in which the resource exists or will exist.
    pub region: String,
}


```

```
$ kopium --docs --filename tests/cmd/generate/crds/argocdexports.argoproj.io.yaml
// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename tests/cmd/generate/crds/argocdexports.argoproj.io.yaml
// kopium version: [..]

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
}
use self::prelude::*;

/// ArgoCDExportSpec defines the desired state of ArgoCDExport
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug)]
#[kube(group = "argoproj.io", version = "v1alpha1", kind = "ArgoCDExport", plural = "argocdexports")]
#[kube(namespaced)]
#[kube(status = "ArgoCdExportStatus")]
#[kube(schema = "disabled")]
pub struct ArgoCdExportSpec {
    /// Argocd is the name of the ArgoCD instance to export.
    pub argocd: String,
    /// Image is the container image to use for the export Job.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// Schedule in Cron format, see <https://en.wikipedia.org/wiki/Cron.>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schedule: Option<String>,
    /// Storage defines the storage configuration options.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<ArgoCdExportStorage>,
    /// Version is the tag/digest to use for the export Job container image.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Storage defines the storage configuration options.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ArgoCdExportStorage {
    /// Backend defines the storage backend to use, must be "local" (the default), "aws", "azure" or "gcp".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub backend: Option<String>,
    /// PVC is the desired characteristics for a PersistentVolumeClaim.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pvc: Option<ArgoCdExportStoragePvc>,
    /// SecretName is the name of a Secret with encryption key, credentials, etc.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretName")]
    pub secret_name: Option<String>,
}

/// PVC is the desired characteristics for a PersistentVolumeClaim.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ArgoCdExportStoragePvc {
    /// accessModes contains the desired access modes the volume should have.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// dataSource field can be used to specify either:
    /// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
    /// * An existing PVC (PersistentVolumeClaim)
    /// If the provisioner or an external controller can support the specified data source,
    /// it will create a new volume based on the contents of the specified data source.
    /// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
    /// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
    /// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<ArgoCdExportStoragePvcDataSource>,
    /// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
    /// volume is desired. This may be any object from a non-empty API group (non
    /// core object) or a PersistentVolumeClaim object.
    /// When this field is specified, volume binding will only succeed if the type of
    /// the specified object matches some installed volume populator or dynamic
    /// provisioner.
    /// This field will replace the functionality of the dataSource field and as such
    /// if both fields are non-empty, they must have the same value. For backwards
    /// compatibility, when namespace isn't specified in dataSourceRef,
    /// both fields (dataSource and dataSourceRef) will be set to the same
    /// value automatically if one of them is empty and the other is non-empty.
    /// When namespace is specified in dataSourceRef,
    /// dataSource isn't set to the same value and must be empty.
    /// There are three important differences between dataSource and dataSourceRef:
    /// * While dataSource only allows two specific types of objects, dataSourceRef
    ///   allows any non-core object, as well as PersistentVolumeClaim objects.
    /// * While dataSource ignores disallowed values (dropping them), dataSourceRef
    ///   preserves all values, and generates an error if a disallowed value is
    ///   specified.
    /// * While dataSource only allows local objects, dataSourceRef allows objects
    ///   in any namespaces.
    /// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
    /// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceRef")]
    pub data_source_ref: Option<ArgoCdExportStoragePvcDataSourceRef>,
    /// resources represents the minimum resources the volume should have.
    /// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
    /// that are lower than previous value but must still be higher than capacity recorded in the
    /// status field of the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ArgoCdExportStoragePvcResources>,
    /// selector is a label query over volumes to consider for binding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<ArgoCdExportStoragePvcSelector>,
    /// storageClassName is the name of the StorageClass required by the claim.
    /// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
    /// If specified, the CSI driver will create or update the volume with the attributes defined
    /// in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
    /// it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
    /// will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
    /// If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
    /// will be set by the persistentvolume controller if it exists.
    /// If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
    /// set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
    /// exists.
    /// More info: <https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/>
    /// (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeAttributesClassName")]
    pub volume_attributes_class_name: Option<String>,
    /// volumeMode defines what type of volume is required by the claim.
    /// Value of Filesystem is implied when not included in claim spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
    /// volumeName is the binding reference to the PersistentVolume backing this claim.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// dataSource field can be used to specify either:
/// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
/// * An existing PVC (PersistentVolumeClaim)
/// If the provisioner or an external controller can support the specified data source,
/// it will create a new volume based on the contents of the specified data source.
/// When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
/// and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
/// If the namespace is specified, then dataSourceRef will not be copied to dataSource.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ArgoCdExportStoragePvcDataSource {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
}

/// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
/// volume is desired. This may be any object from a non-empty API group (non
/// core object) or a PersistentVolumeClaim object.
/// When this field is specified, volume binding will only succeed if the type of
/// the specified object matches some installed volume populator or dynamic
/// provisioner.
/// This field will replace the functionality of the dataSource field and as such
/// if both fields are non-empty, they must have the same value. For backwards
/// compatibility, when namespace isn't specified in dataSourceRef,
/// both fields (dataSource and dataSourceRef) will be set to the same
/// value automatically if one of them is empty and the other is non-empty.
/// When namespace is specified in dataSourceRef,
/// dataSource isn't set to the same value and must be empty.
/// There are three important differences between dataSource and dataSourceRef:
/// * While dataSource only allows two specific types of objects, dataSourceRef
///   allows any non-core object, as well as PersistentVolumeClaim objects.
/// * While dataSource ignores disallowed values (dropping them), dataSourceRef
///   preserves all values, and generates an error if a disallowed value is
///   specified.
/// * While dataSource only allows local objects, dataSourceRef allows objects
///   in any namespaces.
/// (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
/// (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ArgoCdExportStoragePvcDataSourceRef {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
    /// Namespace is the namespace of resource being referenced
    /// Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
    /// (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// resources represents the minimum resources the volume should have.
/// If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
/// that are lower than previous value but must still be higher than capacity recorded in the
/// status field of the claim.
/// More info: <https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources>
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ArgoCdExportStoragePvcResources {
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, IntOrString>>,
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value. Requests cannot exceed Limits.
    /// More info: <https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, IntOrString>>,
}

/// selector is a label query over volumes to consider for binding.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ArgoCdExportStoragePvcSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ArgoCdExportStoragePvcSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    /// map is equivalent to an element of matchExpressions, whose key field is "key", the
    /// operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that
/// relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ArgoCdExportStoragePvcSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. This array is replaced during a strategic
    /// merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// ArgoCDExportStatus defines the observed state of ArgoCDExport
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ArgoCdExportStatus {
    /// Phase is a simple, high-level summary of where the ArgoCDExport is in its lifecycle.
    /// There are five possible phase values:
    /// Pending: The ArgoCDExport has been accepted by the Kubernetes system, but one or more of the required resources have not been created.
    /// Running: All of the containers for the ArgoCDExport are still running, or in the process of starting or restarting.
    /// Succeeded: All containers for the ArgoCDExport have terminated in success, and will not be restarted.
    /// Failed: At least one container has terminated in failure, either exited with non-zero status or was terminated by the system.
    /// Unknown: For some reason the state of the ArgoCDExport could not be obtained.
    pub phase: String,
}


```

```
$ kopium --docs --filename tests/cmd/generate/crds/authorizers.apigatewayv2.services.k8s.aws.yaml
// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename tests/cmd/generate/crds/authorizers.apigatewayv2.services.k8s.aws.yaml
// kopium version: [..]

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
}
use self::prelude::*;

/// AuthorizerSpec defines the desired state of Authorizer.
/// 
/// Represents an authorizer.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug)]
#[kube(group = "apigatewayv2.services.k8s.aws", version = "v1alpha1", kind = "Authorizer", plural = "authorizers")]
#[kube(namespaced)]
#[kube(status = "AuthorizerStatus")]
#[kube(schema = "disabled")]
pub struct AuthorizerSpec {
    /// The API identifier.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiID")]
    pub api_id: Option<String>,
    /// AWSResourceReferenceWrapper provides a wrapper around *AWSResourceReference
    /// type to provide more user friendly syntax for references using 'from' field
    /// Ex:
    /// APIIDRef:
    /// 
    /// 	from:
    /// 	  name: my-api
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiRef")]
    pub api_ref: Option<AuthorizerApiRef>,
    /// Specifies the required credentials as an IAM role for API Gateway to invoke
    /// the authorizer. To specify an IAM role for API Gateway to assume, use the
    /// role's Amazon Resource Name (ARN). To use resource-based permissions on the
    /// Lambda function, don't specify this parameter. Supported only for REQUEST
    /// authorizers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizerCredentialsARN")]
    pub authorizer_credentials_arn: Option<String>,
    /// Specifies the format of the payload sent to an HTTP API Lambda authorizer.
    /// Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0.
    /// To learn more, see Working with AWS Lambda authorizers for HTTP APIs (<https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizerPayloadFormatVersion")]
    pub authorizer_payload_format_version: Option<String>,
    /// The time to live (TTL) for cached authorizer results, in seconds. If it equals
    /// 0, authorization caching is disabled. If it is greater than 0, API Gateway
    /// caches authorizer responses. The maximum value is 3600, or 1 hour. Supported
    /// only for HTTP API Lambda authorizers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizerResultTTLInSeconds")]
    pub authorizer_result_ttl_in_seconds: Option<i64>,
    /// The authorizer type. Specify REQUEST for a Lambda function using incoming
    /// request parameters. Specify JWT to use JSON Web Tokens (supported only for
    /// HTTP APIs).
    #[serde(rename = "authorizerType")]
    pub authorizer_type: String,
    /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers,
    /// this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations.
    /// In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api}
    /// , where {region} is the same as the region hosting the Lambda function, path
    /// indicates that the remaining substring in the URI should be treated as the
    /// path to the resource, including the initial /. For Lambda functions, this
    /// is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported
    /// only for REQUEST authorizers.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizerURI")]
    pub authorizer_uri: Option<String>,
    /// Specifies whether a Lambda authorizer returns a response in a simple format.
    /// By default, a Lambda authorizer must return an IAM policy. If enabled, the
    /// Lambda authorizer can return a boolean value instead of an IAM policy. Supported
    /// only for HTTP APIs. To learn more, see Working with AWS Lambda authorizers
    /// for HTTP APIs (<https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html)>
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableSimpleResponses")]
    pub enable_simple_responses: Option<bool>,
    /// The identity source for which authorization is requested.
    /// 
    /// For a REQUEST authorizer, this is optional. The value is a set of one or
    /// more mapping expressions of the specified request parameters. The identity
    /// source can be headers, query string parameters, stage variables, and context
    /// parameters. For example, if an Auth header and a Name query string parameter
    /// are defined as identity sources, this value is route.request.header.Auth,
    /// route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection
    /// expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name.
    /// These parameters are used to perform runtime validation for Lambda-based
    /// authorizers by verifying all of the identity-related request parameters are
    /// present in the request, not null, and non-empty. Only when this is true does
    /// the authorizer invoke the authorizer Lambda function. Otherwise, it returns
    /// a 401 Unauthorized response without calling the Lambda function. For HTTP
    /// APIs, identity sources are also used as the cache key when caching is enabled.
    /// To learn more, see Working with AWS Lambda authorizers for HTTP APIs (<https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html).>
    /// 
    /// For JWT, a single entry that specifies where to extract the JSON Web Token
    /// (JWT) from inbound requests. Currently only header-based and query parameter-based
    /// selections are supported, for example $request.header.Authorization.
    #[serde(rename = "identitySource")]
    pub identity_source: Vec<String>,
    /// This parameter is not used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "identityValidationExpression")]
    pub identity_validation_expression: Option<String>,
    /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer
    /// type. Supported only for HTTP APIs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jwtConfiguration")]
    pub jwt_configuration: Option<AuthorizerJwtConfiguration>,
    /// The name of the authorizer.
    pub name: String,
}

/// AWSResourceReferenceWrapper provides a wrapper around *AWSResourceReference
/// type to provide more user friendly syntax for references using 'from' field
/// Ex:
/// APIIDRef:
/// 
/// 	from:
/// 	  name: my-api
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct AuthorizerApiRef {
    /// AWSResourceReference provides all the values necessary to reference another
    /// k8s resource for finding the identifier(Id/ARN/Name)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<AuthorizerApiRefFrom>,
}

/// AWSResourceReference provides all the values necessary to reference another
/// k8s resource for finding the identifier(Id/ARN/Name)
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct AuthorizerApiRefFrom {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Represents the configuration of a JWT authorizer. Required for the JWT authorizer
/// type. Supported only for HTTP APIs.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct AuthorizerJwtConfiguration {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub audience: Option<Vec<String>>,
    /// A string representation of a URI with a length between [1-2048].
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub issuer: Option<String>,
}

/// AuthorizerStatus defines the observed state of Authorizer
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct AuthorizerStatus {
    /// All CRs managed by ACK have a common `Status.ACKResourceMetadata` member
    /// that is used to contain resource sync state, account ownership,
    /// constructed ARN for the resource
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ackResourceMetadata")]
    pub ack_resource_metadata: Option<AuthorizerStatusAckResourceMetadata>,
    /// The authorizer identifier.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authorizerID")]
    pub authorizer_id: Option<String>,
    /// All CRs managed by ACK have a common `Status.Conditions` member that
    /// contains a collection of `ackv1alpha1.Condition` objects that describe
    /// the various terminal states of the CR and its backend AWS service API
    /// resource
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
}

/// All CRs managed by ACK have a common `Status.ACKResourceMetadata` member
/// that is used to contain resource sync state, account ownership,
/// constructed ARN for the resource
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct AuthorizerStatusAckResourceMetadata {
    /// ARN is the Amazon Resource Name for the resource. This is a
    /// globally-unique identifier and is set only by the ACK service controller
    /// once the controller has orchestrated the creation of the resource OR
    /// when it has verified that an "adopted" resource (a resource where the
    /// ARN annotation was set by the Kubernetes user on the CR) exists and
    /// matches the supplied CR's Spec field values.
    /// <https://github.com/aws/aws-controllers-k8s/issues/270>
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub arn: Option<String>,
    /// OwnerAccountID is the AWS Account ID of the account that owns the
    /// backend AWS service API resource.
    #[serde(rename = "ownerAccountID")]
    pub owner_account_id: String,
    /// Region is the AWS region in which the resource exists or will exist.
    pub region: String,
}


```

```
$ kopium --docs --filename tests/cmd/generate/crds/postgresqls.acid.zalan.do.yaml
// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium --docs --filename tests/cmd/generate/crds/postgresqls.acid.zalan.do.yaml
// kopium version: [..]

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug)]
#[kube(group = "acid.zalan.do", version = "v1", kind = "postgresql", plural = "postgresqls")]
#[kube(namespaced)]
#[kube(schema = "disabled")]
pub struct PostgresqlSpec {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalVolumes")]
    pub additional_volumes: Option<Vec<PostgresqlAdditionalVolumes>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "allowedSourceRanges")]
    pub allowed_source_ranges: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clone: Option<PostgresqlClone>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "connectionPooler")]
    pub connection_pooler: Option<PostgresqlConnectionPooler>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub databases: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dockerImage")]
    pub docker_image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableConnectionPooler")]
    pub enable_connection_pooler: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableLogicalBackup")]
    pub enable_logical_backup: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableMasterLoadBalancer")]
    pub enable_master_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableMasterPoolerLoadBalancer")]
    pub enable_master_pooler_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableReplicaConnectionPooler")]
    pub enable_replica_connection_pooler: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableReplicaLoadBalancer")]
    pub enable_replica_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableReplicaPoolerLoadBalancer")]
    pub enable_replica_pooler_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableShmVolume")]
    pub enable_shm_volume: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initContainers")]
    pub init_containers: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    /// deprecated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "init_containers")]
    pub init_containers_x: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logicalBackupRetention")]
    pub logical_backup_retention: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "logicalBackupSchedule")]
    pub logical_backup_schedule: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maintenanceWindows")]
    pub maintenance_windows: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "masterServiceAnnotations")]
    pub master_service_annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeAffinity")]
    pub node_affinity: Option<PostgresqlNodeAffinity>,
    #[serde(rename = "numberOfInstances")]
    pub number_of_instances: i64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patroni: Option<PostgresqlPatroni>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podAnnotations")]
    pub pod_annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podPriorityClassName")]
    pub pod_priority_class_name: Option<String>,
    /// deprecated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pod_priority_class_name")]
    pub pod_priority_class_name_x: Option<String>,
    pub postgresql: PostgresqlPostgresql,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preparedDatabases")]
    pub prepared_databases: Option<BTreeMap<String, PostgresqlPreparedDatabases>>,
    /// deprecated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaLoadBalancer")]
    pub replica_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replicaServiceAnnotations")]
    pub replica_service_annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresqlResources>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "schedulerName")]
    pub scheduler_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceAnnotations")]
    pub service_annotations: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sidecars: Option<Vec<BTreeMap<String, serde_json::Value>>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spiloFSGroup")]
    pub spilo_fs_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spiloRunAsGroup")]
    pub spilo_run_as_group: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "spiloRunAsUser")]
    pub spilo_run_as_user: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub standby: Option<PostgresqlStandby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub streams: Option<Vec<PostgresqlStreams>>,
    #[serde(rename = "teamId")]
    pub team_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls: Option<PostgresqlTls>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<PostgresqlTolerations>>,
    /// deprecated
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useLoadBalancer")]
    pub use_load_balancer: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub users: Option<BTreeMap<String, Vec<String>>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usersIgnoringSecretRotation")]
    pub users_ignoring_secret_rotation: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usersWithInPlaceSecretRotation")]
    pub users_with_in_place_secret_rotation: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "usersWithSecretRotation")]
    pub users_with_secret_rotation: Option<Vec<String>>,
    pub volume: PostgresqlVolume,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlAdditionalVolumes {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isSubPathExpr")]
    pub is_sub_path_expr: Option<bool>,
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetContainers")]
    pub target_containers: Option<Vec<String>>,
    #[serde(rename = "volumeSource")]
    pub volume_source: BTreeMap<String, serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlClone {
    pub cluster: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_access_key_id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_endpoint: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_force_path_style: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_secret_access_key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_wal_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uid: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlConnectionPooler {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dockerImage")]
    pub docker_image: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxDBConnections")]
    pub max_db_connections: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<PostgresqlConnectionPoolerMode>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberOfInstances")]
    pub number_of_instances: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<PostgresqlConnectionPoolerResources>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schema: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum PostgresqlConnectionPoolerMode {
    #[serde(rename = "session")]
    Session,
    #[serde(rename = "transaction")]
    Transaction,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlConnectionPoolerResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<PostgresqlConnectionPoolerResourcesLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<PostgresqlConnectionPoolerResourcesRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlConnectionPoolerResourcesLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlConnectionPoolerResourcesRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlNodeAffinity {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredDuringSchedulingIgnoredDuringExecution")]
    pub preferred_during_scheduling_ignored_during_execution: Option<Vec<PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredDuringSchedulingIgnoredDuringExecution")]
    pub required_during_scheduling_ignored_during_execution: Option<PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    pub preference: PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    #[serde(rename = "nodeSelectorTerms")]
    pub node_selector_terms: Vec<PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlPatroni {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub failsafe_mode: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub initdb: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub loop_wait: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub maximum_lag_on_failover: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pg_hba: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub retry_timeout: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub slots: Option<BTreeMap<String, BTreeMap<String, String>>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub synchronous_mode: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub synchronous_mode_strict: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub synchronous_node_count: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlPostgresql {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parameters: Option<BTreeMap<String, String>>,
    pub version: PostgresqlPostgresqlVersion,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum PostgresqlPostgresqlVersion {
    #[serde(rename = "13")]
    r#_13,
    #[serde(rename = "14")]
    r#_14,
    #[serde(rename = "15")]
    r#_15,
    #[serde(rename = "16")]
    r#_16,
    #[serde(rename = "17")]
    r#_17,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlPreparedDatabases {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultUsers")]
    pub default_users: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extensions: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schemas: Option<BTreeMap<String, PostgresqlPreparedDatabasesSchemas>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretNamespace")]
    pub secret_namespace: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlPreparedDatabasesSchemas {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultRoles")]
    pub default_roles: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "defaultUsers")]
    pub default_users: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlResources {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<PostgresqlResourcesLimits>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<PostgresqlResourcesRequests>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlResourcesLimits {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hugepages-1Gi")]
    pub hugepages_1gi: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hugepages-2Mi")]
    pub hugepages_2mi: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlResourcesRequests {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hugepages-1Gi")]
    pub hugepages_1gi: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "hugepages-2Mi")]
    pub hugepages_2mi: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlStandby {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gs_wal_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3_wal_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub standby_host: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub standby_port: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlStreams {
    #[serde(rename = "applicationId")]
    pub application_id: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "batchSize")]
    pub batch_size: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cpu: Option<String>,
    pub database: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableRecovery")]
    pub enable_recovery: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filter: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub memory: Option<String>,
    pub tables: BTreeMap<String, PostgresqlStreamsTables>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlStreamsTables {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "eventType")]
    pub event_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "idColumn")]
    pub id_column: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignoreRecovery")]
    pub ignore_recovery: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "payloadColumn")]
    pub payload_column: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "recoveryEventType")]
    pub recovery_event_type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlTls {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caSecretName")]
    pub ca_secret_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateFile")]
    pub certificate_file: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "privateKeyFile")]
    pub private_key_file: Option<String>,
    #[serde(rename = "secretName")]
    pub secret_name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlTolerations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<PostgresqlTolerationsEffect>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<PostgresqlTolerationsOperator>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum PostgresqlTolerationsEffect {
    NoExecute,
    NoSchedule,
    PreferNoSchedule,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum PostgresqlTolerationsOperator {
    Equal,
    Exists,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlVolume {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub iops: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "isSubPathExpr")]
    pub is_sub_path_expr: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<PostgresqlVolumeSelector>,
    pub size: String,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClass")]
    pub storage_class: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subPath")]
    pub sub_path: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub throughput: Option<i64>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlVolumeSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<PostgresqlVolumeSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, serde_json::Value>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PostgresqlVolumeSelectorMatchExpressions {
    pub key: String,
    pub operator: PostgresqlVolumeSelectorMatchExpressionsOperator,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum PostgresqlVolumeSelectorMatchExpressionsOperator {
    DoesNotExist,
    Exists,
    In,
    NotIn,
}


```
