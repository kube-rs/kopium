use std::fmt::Write;

use anyhow::Context;

/// For the purposes of this example, we'll just fetch each CRD individually, but in a "real" build context
/// this would probably be a link to something like a target Helm chart, an archive of the target operator's
/// full manifest, etc. (instead of an array of direct URLs) that would be processed by the build script.
///
/// The URLs below are for the [Prometheus Operator] CRDs, but `kopium` can be used with any CRD you want
/// to generate types for.
///
/// [Prometheus Operator]: https://github.com/prometheus-operator/prometheus-operator/
const TARGETS: &[&str] = &[
    "https://raw.githubusercontent.com/prometheus-operator/prometheus-operator/refs/heads/main/example/prometheus-operator-crd-full/monitoring.coreos.com_alertmanagerconfigs.yaml",
    "https://raw.githubusercontent.com/prometheus-operator/prometheus-operator/refs/heads/main/example/prometheus-operator-crd-full/monitoring.coreos.com_alertmanagers.yaml",
    "https://raw.githubusercontent.com/prometheus-operator/prometheus-operator/refs/heads/main/example/prometheus-operator-crd-full/monitoring.coreos.com_podmonitors.yaml",
    "https://raw.githubusercontent.com/prometheus-operator/prometheus-operator/refs/heads/main/example/prometheus-operator-crd-full/monitoring.coreos.com_probes.yaml",
    "https://raw.githubusercontent.com/prometheus-operator/prometheus-operator/refs/heads/main/example/prometheus-operator-crd-full/monitoring.coreos.com_prometheusagents.yaml",
    "https://raw.githubusercontent.com/prometheus-operator/prometheus-operator/refs/heads/main/example/prometheus-operator-crd-full/monitoring.coreos.com_prometheuses.yaml",
    "https://raw.githubusercontent.com/prometheus-operator/prometheus-operator/refs/heads/main/example/prometheus-operator-crd-full/monitoring.coreos.com_prometheusrules.yaml",
    "https://raw.githubusercontent.com/prometheus-operator/prometheus-operator/refs/heads/main/example/prometheus-operator-crd-full/monitoring.coreos.com_scrapeconfigs.yaml",
    "https://raw.githubusercontent.com/prometheus-operator/prometheus-operator/refs/heads/main/example/prometheus-operator-crd-full/monitoring.coreos.com_servicemonitors.yaml",
    "https://raw.githubusercontent.com/prometheus-operator/prometheus-operator/refs/heads/main/example/prometheus-operator-crd-full/monitoring.coreos.com_thanosrulers.yaml",
];

/// In a "real" build-script this would just be the manifest of the target crate itself. This example is only
/// intended to showcase how `kopium` might be used in a build-script-like *context*, however. To keep the example
/// complete, self-contained, and tidy, we'll include this example `Cargo.toml`, which includes all the dependencies
/// we need to generate the types for the Prometheus Operator CRDs and only write it out if one isn't already present
/// in the crate directory.
const CRATE_MANIFEST: &str = r#"[package]
name = "prometheus-operator-types"
description = "Auto-generated Prometheus Operator CRD types crate"
version = "0.0.1"
edition = "2021"
authors = ["kopium <kopoum@example.dev>"]
license = "Apache-2.0"
repository = "https://example.com/kopium/prometheus-operator-types"
keywords = ["kubernetes", "openapi", "monitoring", "prometheus"]
categories = ["data-structures"]

[dependencies]
k8s-openapi = { version = "0.26.0", features = ["latest", "schemars"] }
kube = { version = "2.0.1", features = ["derive"] }
schemars = { version = "1", features = ["derive"] }
typed-builder = { version = "0.22", default-features = false }

[build-dependencies]
anyhow = "1"
env_logger = { version = "0.11", default-features = false }
heck = { version = "0.5", default-features = false }
kopium = { version = "0.22", default-features = false }
log = { version = "0.4", default-features = false, features = ["std"] }
reqwest = { version = "0.12", default-features = false, features = ["charset", "http2", "rustls-tls", "rustls-tls-native-roots"] }
"#;

/// This is an example of the *non*-generated part(s) of our hypothetical example crate that uses
/// `kopium` in its build script to keep the generated parts up to date.
const GENERATED_LIB: &str = r#"//! Autogenerated Prometheus Operator CRD types crate
//!
//! This crate is automatically generated by the `kopium` build script.
//!
//! For more information, see the [kopium](https://github.com/kube-rs/kopium/blob/main/examples/from-build-script.rs) crate examples.

mod generated;

#[allow(unused_imports)]
pub use generated::*;

// Note: anything added to or changed in the `generated` module (i.e. `generated.rs`, *or* `generated/*.rs`)
// will be overwritten by the build script, so any extension of the generated types should be added here

impl Alertmanager {
    /// A custom method for one of the generated types that won't be overwritten by the build script
    pub fn some_custom_method(&self) -> bool {
        todo!()
    }
}

"#;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    env_logger::init();

    let crate_dir = std::env::args().nth(1);

    if crate_dir.as_deref() == Some("--help") {
        println!(
            "\nUsage: cargo run -p {} --example {} [path]\n",
            env!("CARGO_PKG_NAME"),
            env!("CARGO_BIN_NAME")
        );

        println!(
            "\tpath: the path to the crate directory to generate types for (defaults to a temporary directory)\n"
        );

        return Ok(());
    }

    let crate_path = initialize_crate_dir(crate_dir)?;

    let (client, generator) = (
        reqwest::Client::new(),
        kopium::TypeGenerator::builder()
            .schema_mode(kopium::SchemaMode::Derived)
            .smart_derive_elision(true)
            .emit_docs(true)
            .builders(true)
            .build(),
    );

    let (mut uses, mut modules) = (
        String::new(),
        format!(
            "// WARNING: automatically generated by `kopium (v{})` - manual changes will be overwritten\n\n",
            env!("CARGO_PKG_VERSION")
        ),
    );

    for target in TARGETS {
        let Some(stem) = extract_file_stem(target) else {
            log::warn!("unable to extract file stem from URL, skipping: {}", target);
            continue;
        };

        let data = client.get(*target).send().await?.bytes().await?;
        let crd = serde_yaml::from_slice(data.iter().as_slice())?;

        let generated = generator
            .generate_rust_types_for(&crd, Option::<String>::None)
            .await?;

        let path = crate_path
            .join("src")
            .join("generated")
            .join(stem)
            .with_extension("rs");

        let updated = path.is_file();

        if let Err(error) = std::fs::write(&path, generated).context("failed to write generated file") {
            log::error!("failed to write generated types to: {}", path.display());
            log::error!("{error:#?}\n");
            continue;
        }

        log::info!(
            "{}: {}",
            if updated {
                "updated generated types in"
            } else {
                "wrote generated types to"
            },
            path.display()
        );

        if let Err(_) = writeln!(&mut modules, "pub mod {stem};") {
            log::error!("failed to add generated `{stem}` module to `generated.rs`");
        }

        if let Err(_) = writeln!(&mut uses, "pub use {stem}::*;") {
            log::error!("failed to add re-export(s) from generated `{stem}` module to `generated.rs`");
        }
    }

    writeln!(&mut modules, "\n{uses}\n")?;

    let generated_rs = crate_path.join("src").join("generated.rs");

    std::fs::write(&generated_rs, modules)?;

    log::info!("wrote `generated` module to: {}", generated_rs.display());

    Ok(())
}

/// Extract the file name "stem" of the target CRD from the provided URL
fn extract_file_stem(url: &str) -> Option<&str> {
    url
        // https://.../monitoring.coreos.com_alertmanagerconfigs.yaml -> monitoring.coreos.com_alertmanagerconfigs.yaml
        .rsplit_once('/')
        .map(|(_, name)| name)?
        // monitoring.coreos.com_alertmanagerconfigs.yaml -> alertmanagerconfigs.yaml
        .rsplit_once('_')
        .map(|(_, name)| name)?
        // alertmanagerconfigs.yaml -> alertmanagerconfigs
        .rsplit_once('.')
        .map(|(name, _)| name)
}

/// Create the basic rust crate "structure" for the example crate we're generating and return
/// its on-disk path.
///
/// Note: in an *actual* build script, `path` would just be `env!("CARGO_MANIFEST_DIR")`,
/// but this example is only intended to showcase how `kopium` might be used in a build-script-like
/// *context*, so we'll use a temporary directory instead
fn initialize_crate_dir(path: Option<impl AsRef<std::path::Path>>) -> anyhow::Result<std::path::PathBuf> {
    let path = path
        .as_ref()
        .map(AsRef::as_ref)
        .map(std::path::Path::to_path_buf)
        .unwrap_or_else(|| std::env::temp_dir().join("prometheus-operator-types"));

    if path.exists() && path.is_file() {
        anyhow::bail!("specified crate path points to a file: {}", path.display());
    }

    // `Path::is_dir` inherently checks for the existence of the directory,
    // so there's no need to call `Path::exists` again/as well here
    if !path.is_dir() {
        std::fs::create_dir_all(&path).context("failed to create crate directory")?;
        log::info!("created top-level crate directory: {}", path.display());
    }

    let manifest = path.join("Cargo.toml");

    if !manifest.is_file() {
        std::fs::write(&manifest, CRATE_MANIFEST).context("failed to write crate manifest")?;
        log::info!("wrote crate manifest to: {}", manifest.display());
    }

    let src_dir = path.join("src");

    if !src_dir.is_dir() {
        std::fs::create_dir_all(&src_dir).context("failed to create crate `src/` directory")?;
        log::info!("created crate `src/` directory: {}", src_dir.display());
    }

    let (lib_rs, generated, generated_rs) = (
        src_dir.join("lib.rs"),
        src_dir.join("generated"),
        src_dir.join("generated.rs"),
    );

    if !lib_rs.is_file() {
        std::fs::write(&lib_rs, GENERATED_LIB).context("failed to write crate `src/lib.rs`")?;
        log::info!("wrote crate `lib.rs` file to: {}", lib_rs.display());
    }

    if !generated_rs.is_file() {
        std::fs::write(&generated_rs, "").context("failed to write crate `src/generated.rs`")?;
        log::info!("wrote crate `generated.rs` file to: {}", generated_rs.display());
    }

    if !generated.is_dir() {
        std::fs::create_dir_all(&generated).context("failed to create crate `src/generated` directory")?;
        log::info!("created crate `src/generated` directory: {}", generated.display());
    }

    Ok(path)
}
